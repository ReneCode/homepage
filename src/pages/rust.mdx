import Layout from "../components/layout"

<Layout>



# Rust (programming language)

[Rust Crash Course](https://www.youtube.com/watch?v=zF34dRivLOw)
[A Gentle Introduction To Rust](https://stevedonovan.github.io/rust-gentle-intro/readme.html)
[The Rust Programming Language](https://doc.rust-lang.org/stable/book/)
[Rust by Example](https://doc.rust-lang.org/rust-by-example/index.html)

```
// version
rustup --version

// update
rustup update

// compiler
rustc

// package manger
cargo

cargo test
```

## Working with cargo

```

cargo new my-new-project
cd my-new-project

// start new project inside the current folder
cargo init

// compile and run programm
// creates the executable on: ./target/debug/<folder-name>
cargo run

// build only (debug)
cargo build


// build only (production)
cargo build --release

// remove programm (target)
cago clean
```

## Function

```
fn test() {
  ...
}


// public
pub fn start() {
  ...
}

```

## Modules

```
// main.rs 
mod output;

fn main() {
  output::run();
}

// output.rs 
pub fn run() {
  println!("hello from output.rs")
}

```

## Formating

```
println!("Number:{}", 42);

println!("Color:{} and length:{}", "red", 150);

// positional arguments
println!("Color:{0} is {1}. again the Color:{0}", "red", 150);

// named arguments
println!("Color:{color} is {price}.", color = "red", price = 55.90);

// traits
println!("Binary: {:b} hex:{:x} octo:{:o} ", 10, 10, 10);
println!("debug out:{:?}", (42, "hello", true) );

```

## Variables

```
let age = 42;
// variables are imutable by default
age = 43;    // will throw an error


// mutable variable
let mut hobbies = 5;
hobbies = 6;    // that is now valid

// const (allways uppercase) with type
const ID: i32 = 42;

let (name, age) = ("susan", 32);
```

## Types 

```
// primitive Types:
// integer: u8 i8 u16 i16 u32 i32 u64 i64 u128 i128
// float: f32 f64
// bool char
// Tuples 
// Arrays (fixed length)

fn run() {
  // 'default' type
  let x = 1;    // default ist i32
  let y = 2.5;  // default ist f64

  // add explicit set 
  let z:i64 = 52321523;

  // max size
  println!("max i32: {}", std::i32::MAX);

  // convention: do not use camelCase - use underscore
  let is_active: bool = true;

  // char - is unicode
  let c = 'A';
  let face = '\u{1F600}'
}
```

## Strings

```
let name = "ben".to_string();
say_hello(name);

fn say_hello(name: String) {
  println!("hello {}", name);
}


pub fun() {
  // imutable fixed-length
  let hello = "Hello";

  // heap-allocated growable (default = imutable)
  let help = String::from("help");
  // mutable
  let mut hi = String::from("hi ")

  // get length
  let len = hello.len();

  // push char
  hi.push('W');

  // push string
  hi.push_str("orld");

  // capacity in bytes
  let capacity = hi.capacity();

  let empty = hi.is_empty();

  // contains
  let contains = hi.contains("World");

  // replace
  let new_hi = hi.replace("World, "Mars");

  // loop through splitted strings (by whitespace)
  for word in hi.split_whitespace() {
    // word will be: "hi"  and  "World"
  }

  // create string with capacity
  let mut new_str = String::with_capacity(10);
  s.push('a');
  s.push('b');

}
```

## Assert

```
assert_eq(2+4, 6);    // will do nothing
assert_eq(2+4, 7);    // will fail
```

## Tuples

Group of values, that can be of different data types. (max 12 elements)

```
let person: (&str, i8) = ("John", 42);

println!("name: {} and is: {}", person.0, person.1)
```

## Arrays
Fixed list of values of the same data type.
```

// array with 5 elements of type i32
let mut numbers: [i32; 5] = [1,2,3,4,5];    // five elements

// get single value, index start from 0
let firstNumber = numbers[0];

// reassign value (if numbers is mutable)
numbers[2] = 42;

// get allocated memory
// size_of_val will get reference (&) to value
let size_bytes = std::mem::size_of_val(&numbers);

// get length of array
let array_len = numbers.len()

// slices of an array (index:0 and indx:1)
let slice: &[i32] = &numbers[0..2];
// {:?} for debug output
println!("Slice of first 2 elements: {:?}", slice)
```


# Vectors
Resizable arrays

```
let mut numbers: Vec<i32> = vec![11,12,13,14];

// reassign
numbers[1] = 22;

// length of vector
let vector_len = numbers.len();

// add element
numbers.push(15);
numbers.push(16);

// pop last element (remove 16)
numbers.pop();

// loop throught vector values
for x in numbers.iter() {
  println!("element: {}", x);
}

// loop and mutate
for x in numbers.iter_mut() {
  *x += 10;    // add 10 to each value
}
```

## use std library

```
let size = std::mem::size_of_val(&number)
```
or
```
use std::mem;
...
let size = mem::size_of_val(&number)
```

# Conditionals



# std::io

```
use std::io;

let mut name = String::new();
io::stdin().read_line(&mut name);

```

# Ownership

the ownership of a value is "moved" to a function that is called with that value.
when the ownership is moved the value can't be used any longer.

```
fn main() {
  let name = "hello".to_string();
  say_hello(name);
            ---- value moved here

  say_hello(name);
            ^^^^ value used here after move
}

fn say_hello(msg: String) {
  println!("Hi {}", msg)
}

```

```
fn main() {
  let name = "hello".to_string();
  say_hello(&name);   // call by reference
  say_hello(&name);
}

fn say_hello(msg: &String) {
  println!("Hi {}", msg)
}

```


"1:00:00

</Layout>
